// MyLanguage.bnf

{
  parserClass="example.parser.MyLanguageParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MyLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="example.psi"
  psiImplPackage="example.psi.impl"

  elementTypeHolderClass="example.psi.MyLanguageTypes"
  elementTypeClass="example.psi.MyLanguageElementType"
  tokenTypeClass="example.psi.MyLanguageTokenType"

  tokens = [
    // 关键字 (Keywords)
    IF_KEYWORD = "if"
    ELSE_KEYWORD = "else"
    WHILE_KEYWORD = "while"
    VAR_KEYWORD = "var"
    PARENT_KEYWORD = "parent"
    TRUE_KEYWORD = "true"
    FALSE_KEYWORD = "false"
    IIF_KEYWORD = "IIF"

    // 标识符 (Identifiers)
    IDENTIFIER = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"
    MACRO_IDENTIFIER = "regexp:Macro_[a-zA-Z_][a-zA-Z0-9_]*"
    JAVA_PATH_IDENTIFIER = "regexp:[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)+"

    // 常量 (Constants)
    SINGLE_QUOTED_STRING = "regexp:'[^']*'"
    DOUBLE_QUOTED_STRING = "regexp:\"[^\"]*\""
    BRACE_QUOTED_STRING = "regexp:\{[^\}]*\}"
    NUMBER = "regexp:[0-9]+"

    // 运算符 (Operators)
    PLUS = "+"
    MINUS = "-"
    MUL = "*"
    DIV = "/"
    AMPERSAND = "&"
    AND_OP = "&&"
    OR_OP = "||"
    DOT = "."
    NOT_OP = "!"

    // Comparison Operators
    LESS_EQUAL = "<="
    GREATER_EQUAL = ">="
    EQUAL_EQUAL = "=="
    NOT_EQUAL = "!="
    LESS = "<"
    GREATER = ">"
    NOT_EQUAL_ALT = "<>"

    // 标点符号 (Punctuation)
    LPAREN = "("
    RPAREN = ")"
    SEMICOLON = ";"
    COMMA = ","
    LBRACE = "{" // Added for block_statement
    RBRACE = "}" // Added for block_statement
  ]
}

// ---------------------------------------------------------------------
// 语法规则 (Grammar Rules)
// ---------------------------------------------------------------------

// The root now expects a sequence of top-level statements.
// A top-level statement can be a single statement potentially followed by a semicolon,
// allowing for chaining. The final semicolon is optional.
root ::= top_level_statement*

private top_level_statement ::= (variable_declaration | expression_sequence | if_statement | while_statement) SEMICOLON? // SEMICOLON is optional at the very end

// New rule to handle multiple expression statements separated by semicolons
expression_sequence ::= expression_statement (SEMICOLON expression_statement)*

// Other statements remain largely the same, but they would appear as part of a top_level_statement
private statement ::= (variable_declaration | expression_sequence | if_statement | while_statement) SEMICOLON?

variable_declaration ::= VAR_KEYWORD IDENTIFIER

expression_statement ::= expression

if_statement ::= IF_KEYWORD LPAREN expression RPAREN statement_block (ELSE_KEYWORD statement_block)?

while_statement ::= WHILE_KEYWORD LPAREN expression RPAREN statement_block

// Helper rule for statements that can be a single statement or a block
// Note: If you want blocks to also allow optional semicolons inside,
// you might need to apply similar SEMICOLON? logic there or use `statement*` if semicolon-optional rules handle it.
private statement_block ::= statement | block_statement

block_statement ::= LBRACE statement* RBRACE // Use LBRACE/RBRACE tokens

// 表达式 (Expressions)
// 优先级从低到高定义，以处理操作符优先级
expression ::= logical_or_expression

private logical_or_expression ::= logical_and_expression (OR_OP logical_and_expression)*

private logical_and_expression ::= comparison_expression (AND_OP comparison_expression)*

private comparison_expression ::= additive_expression ((LESS_EQUAL | GREATER_EQUAL | EQUAL_EQUAL | NOT_EQUAL | LESS | GREATER | NOT_EQUAL_ALT) additive_expression)*

private additive_expression ::= multiplicative_expression ((PLUS | MINUS | AMPERSAND) multiplicative_expression)*

private multiplicative_expression ::= unary_expression ((MUL | DIV) unary_expression)*

private unary_expression ::= NOT_OP unary_expression | primary_expression

// Primary expressions: the most basic elements
primary_expression ::=
  constant
  | function_call
  | variable_reference
  | LPAREN expression RPAREN
  | boolean_constant

variable_reference ::= IDENTIFIER

constant ::= SINGLE_QUOTED_STRING
  | DOUBLE_QUOTED_STRING
  | BRACE_QUOTED_STRING
  | NUMBER

boolean_constant ::= TRUE_KEYWORD | FALSE_KEYWORD

function_call ::=
  (macro_call_expression | IDENTIFIER | java_method_call | parent_call | iif_function_call) LPAREN argument_list? RPAREN

// 新增 macro_call_expression 规则
macro_call_expression ::= MACRO_IDENTIFIER

java_method_call ::= JAVA_PATH_IDENTIFIER

parent_call ::= PARENT_KEYWORD DOT IDENTIFIER

iif_function_call ::= IIF_KEYWORD

argument_list ::= expression (COMMA expression)*