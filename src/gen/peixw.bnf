// MyLanguage.bnf

{
  parserClass="example.parser.MyLanguageParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="MyLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="example.psi"
  psiImplPackage="example.psi.impl"

  elementTypeHolderClass="example.psi.MyLanguageTypes"
  elementTypeClass="example.psi.MyLanguageElementType"
  tokenTypeClass="example.psi.MyLanguageTokenType"

  tokens = [
    // 关键字 (Keywords)
    IF_KEYWORD = "if"
    ELSE_KEYWORD = "else"
    WHILE_KEYWORD = "while"
    VAR_KEYWORD = "var"
    PARENT_KEYWORD = "parent"

    // 标识符 (Identifiers)
    IDENTIFIER = "regexp:[a-zA-Z_][a-zA-Z0-9_]*" // 变量名、函数名等
    MACRO_IDENTIFIER = "regexp:Macro_[a-zA-Z_][a-zA-Z0-9_]*" // 宏标识符
    JAVA_PATH_IDENTIFIER = "regexp:[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)+" // Java路径

    // 常量 (Constants)
    SINGLE_QUOTED_STRING = "regexp:'[^']*'" // 'xxx'
    DOUBLE_QUOTED_STRING = "regexp:\"[^\"]*\"" // "xxx"
    BRACE_QUOTED_STRING = "regexp:\{[^\}]*\}" // {xxx}
    NUMBER_LITERAL = "regexp:[0-9]+" // 数值常量 (新增)
    BOOLEAN_TRUE = "true" // 布尔常量 (新增)
    BOOLEAN_FALSE = "false" // 布尔常量 (新增)


    // 运算符 (Operators)
    PLUS = "+"
    MINUS = "-"
    MUL = "*"
    DIV = "/"
    AMPERSAND = "&" // 字符串拼接
    AND_OP = "&&"
    OR_OP = "||"
    DOT = "."
    NOT_OP = "!" // 逻辑非运算符 (新增)

    // Comparison Operators
    LESS_EQUAL = "<="
    GREATER_EQUAL = ">="
    EQUAL_EQUAL = "=="
    NOT_EQUAL = "!="
    LESS = "<"
    GREATER = ">"
    NOT_EQUAL_ALT = "<>" // 另一种不等于

    // 标点符号 (Punctuation)
    LPAREN = "("
    RPAREN = ")"
    SEMICOLON = ";"
    COMMA = ","
  ]
}

// ---------------------------------------------------------------------
// 语法规则 (Grammar Rules)
// ---------------------------------------------------------------------

root ::= statement*

// Modified: Allowing expression_statement to optionally not end with SEMICOLON
// This makes single expressions like in IIF arguments valid without a trailing semicolon.
private statement ::= (variable_declaration | expression_statement | if_statement | while_statement) (SEMICOLON | <<eof>>)

variable_declaration ::= VAR_KEYWORD IDENTIFIER

// Changed expression_statement to allow optional semicolon
expression_statement ::= expression SEMICOLON?

if_statement ::= IF_KEYWORD LPAREN expression RPAREN statement (ELSE_KEYWORD statement)?

while_statement ::= WHILE_KEYWORD LPAREN expression RPAREN statement

// 表达式 (Expressions)
// 优先级从低到高定义，以处理操作符优先级
expression ::= logical_or_expression

private logical_or_expression ::= logical_and_expression (OR_OP logical_and_expression)*

// Higher precedence for logical AND
private logical_and_expression ::= comparison_expression (AND_OP comparison_expression)*

// Comparison expressions
private comparison_expression ::= unary_expression ((LESS_EQUAL | GREATER_EQUAL | EQUAL_EQUAL | NOT_EQUAL | LESS | GREATER | NOT_EQUAL_ALT) unary_expression)* // Modified: Refers to unary_expression

// Unary expressions (e.g., !exp, -exp) (新增)
private unary_expression ::=
  NOT_OP unary_expression // Logical NOT
  | additive_expression // Other expressions are handled by additive_expression

// Additive expressions (+, -) and string concatenation (&)
private additive_expression ::= multiplicative_expression ((PLUS | MINUS | AMPERSAND) multiplicative_expression)*

// Multiplicative expressions (*, /)
private multiplicative_expression ::= primary_expression ((MUL | DIV) primary_expression)*

// Primary expressions: the most basic elements
primary_expression ::=
  constant
  | function_call
  | variable_reference
  | LPAREN expression RPAREN

variable_reference ::= IDENTIFIER

// Added NUMBER_LITERAL to constant
constant ::= SINGLE_QUOTED_STRING | DOUBLE_QUOTED_STRING | BRACE_QUOTED_STRING | NUMBER_LITERAL | BOOLEAN_TRUE | BOOLEAN_FALSE

function_call ::=
  (MACRO_IDENTIFIER | IDENTIFIER | java_method_call | parent_call) LPAREN argument_list? RPAREN

java_method_call ::= JAVA_PATH_IDENTIFIER

parent_call ::= PARENT_KEYWORD DOT IDENTIFIER

// Added an optional SEMICOLON to argument_list expressions (if you want to be very flexible, but usually not needed inside argument lists)
argument_list ::= expression (COMMA expression)*